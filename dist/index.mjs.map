{"version":3,"sources":["../src/DataSet.ts","../src/Fez.ts","../src/Limon.ts"],"sourcesContent":["export default class DataSet<T> extends Set<T> {\n    some(predicate: (value: T, set: DataSet<T>) => unknown): boolean {\n        for (const value of this) {\n            if (predicate(value, this)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    filter(predicate: (value: T, set: DataSet<T>) => unknown): DataSet<T> {\n        const result = new DataSet<T>();\n        for (const item of this) {\n            if (predicate(item, this)) {\n                result.add(item);\n            }\n        }\n        return result;\n    }\n\n    random(): T | null {\n        const it = this.values();\n        const index = Math.floor(Math.random() * this.size);\n        for (let i = 0; i < index; i++) {\n            it.next();\n        }\n        return it.next().value ?? null;\n    }\n}\n\nexport function ensureDataSet<K, T>(map: Map<K, DataSet<T>>, key: K): DataSet<T> {\n    const set = map.get(key) ?? new DataSet<T>();\n    map.set(key, set);\n    return set;\n}\n","import { Phoneme, Pronunciation } from \"node-cmudict\";\n\nexport default class Fez {\n    public readonly syllables: string[];\n    public readonly lastRawSyllable: string;\n\n    private static formatSyllable(syllable: Phoneme[]): string {\n        return syllable.map(phoneme => phoneme.phoneme).join(\" \");\n    }\n\n    constructor(public readonly pronunciation: Pronunciation) {\n        this.syllables = [];\n        let syllable: Phoneme[] = [];\n        let excess: Phoneme[] = [];\n        for (const phoneme of this.pronunciation.phonemes) {\n            if (phoneme.stress != null) {\n                if (syllable.length) {\n                    excess = [];\n                    this.syllables.push(Fez.formatSyllable(syllable));\n                }\n                syllable = [phoneme];\n            }\n            else if (syllable[0]?.stress && syllable[0].stress < syllable.length) {\n                syllable.push(phoneme);\n            }\n            else {\n                excess.push(phoneme);\n            }\n        }\n        if (syllable.length) {\n            this.lastRawSyllable = Fez.formatSyllable(syllable.concat(excess));\n            this.syllables.push(Fez.formatSyllable(syllable));\n        }\n        else { // Some donkus decided to create a pronunciation with no stressed phonemes\n            this.lastRawSyllable = this.pronunciation.phonemes.join(\" \");\n            this.syllables = [this.lastRawSyllable];\n        }\n    }\n\n    public get syllableCount(): number {\n        return this.syllables.length;\n    }\n\n    public get lastSyllable(): string {\n        return this.syllables[this.syllables.length - 1];\n    }\n}\n","import { Entry, getDict } from \"node-cmudict\";\nimport DataSet, { ensureDataSet } from \"./DataSet\";\nimport Fez from \"./Fez\";\n\nexport default class Limon {\n    private static _instance: Limon;\n\n    private _dict: Map<string, Entry> | null;\n    public readonly rhymeData: Map<string, DataSet<Fez>>;\n\n    private constructor() {\n        this._dict = null;\n        this.rhymeData = new Map<string, DataSet<Fez>>();\n    }\n\n    /**\n     * Get the singleton instance of the class.\n     */\n    public static getInstance(): Limon {\n        if (!Limon._instance) {\n            Limon._instance = new Limon();\n        }\n        return Limon._instance;\n    }\n\n    public get dict() {\n        return this._dict;\n    }\n\n    public get initialized(): boolean {\n        return Boolean(this._dict && this.rhymeData.size);\n    }\n\n    /**\n     * Set the cmudict dictionary. Overwrites the current dictionary if it exists.\n     * @param dict The dictionary to use. Defaults to getting a new cmudict dictionary.\n     */\n    public setDict(dict?: Map<string, Entry>): void {\n        this._dict = dict ?? getDict();\n    }\n\n    /**\n     * Parse the dictionary for syllables\n     */\n    public init(): void {\n        if (!this._dict) {\n            this.setDict();\n        }\n        for (const entry of this._dict!.values()) {\n            for (const pronunciation of entry.pronunciations) {\n                const fez = new Fez(pronunciation);\n                if (fez.syllableCount === 1) {\n                    const data = ensureDataSet(this.rhymeData, fez.lastSyllable);\n                    if (!data.some(other => pronunciation.equals(other.pronunciation))) {\n                        data.add(fez);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Limon fez!\n     * @param word The word to nonsensify\n     */\n    public exec(word: string): string | null {\n        if (!this.initialized) {\n            this.init();\n        }\n        const formatted = word.trim().toLowerCase();\n        const entry = this._dict!.get(formatted);\n        if (!entry) {\n            return null;\n        }\n        const variations = new DataSet<string>();\n        for (const pronunciation of entry.pronunciations) {\n            const fez = new Fez(pronunciation);\n            let output: string[] = [];\n            for (let i = 0; i < fez.syllableCount; i++) {\n                const data = this.rhymeData.get(fez.syllables[i]);\n                if (data) {\n                    const rhymes = i === fez.syllableCount - 1 ?\n                        data.filter(other => other.lastRawSyllable === fez.lastRawSyllable) :\n                        data;\n                    const match = rhymes.random();\n                    if (match) {\n                        output.push(match.pronunciation.entry.name);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            if (output.length === fez.syllableCount) {\n                variations.add(output.join(\"\"));\n            }\n        }\n        return variations.random();\n    }\n}\n"],"mappings":"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","names":["DataSet","_DataSet","predicate","value","result","item","it","index","i","ensureDataSet","map","key","set","Fez","_Fez","pronunciation","syllable","excess","phoneme","getDict","Limon","_Limon","dict","getDict","entry","pronunciation","fez","Fez","data","ensureDataSet","other","word","formatted","variations","DataSet","output","i","match"]}