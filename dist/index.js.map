{"version":3,"sources":["../src/index.ts","../src/DataSet.ts","../src/Fez.ts","../src/Limon.ts"],"sourcesContent":["export { default as DataSet } from \"./DataSet\";\nexport { default as Fez } from \"./Fez\";\nexport { default as Limon } from \"./Limon\";\n","export default class DataSet<T> extends Set<T> {\n    some(predicate: (value: T) => unknown): boolean {\n        for (const value of this) {\n            if (predicate(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    filter(predicate: (value: T) => unknown): DataSet<T> {\n        const result = new DataSet<T>();\n        for (const item of this) {\n            if (predicate(item)) {\n                result.add(item);\n            }\n        }\n        return result;\n    }\n\n    random(): T | null {\n        const it = this.values();\n        const index = Math.floor(Math.random() * this.size);\n        for (let i = 0; i < index; i++) {\n            it.next();\n        }\n        return it.next().value ?? null;\n    }\n}\n\nexport function ensureDataSet<K, T>(map: Map<K, DataSet<T>>, key: K): DataSet<T> {\n    const set = map.get(key) ?? new DataSet<T>();\n    map.set(key, set);\n    return set;\n}\n","import { Phoneme, Pronunciation } from \"node-cmudict\";\n\nexport default class Fez {\n    public readonly syllables: string[];\n    public readonly lastRawSyllable: string;\n\n    constructor(public readonly pronunciation: Pronunciation) {\n        this.syllables = [];\n        let syllable: Phoneme[] = [];\n        let excess: Phoneme[] = [];\n        for (const phoneme of this.pronunciation.phonemes) {\n            if (phoneme.stress != null) {\n                if (syllable.length) {\n                    excess = [];\n                    this.syllables.push(syllable.join(\" \"));\n                }\n                syllable = [phoneme];\n            }\n            else if (syllable[0]?.stress && syllable[0].stress < syllable.length) {\n                syllable.push(phoneme);\n            }\n            else {\n                excess.push(phoneme);\n            }\n        }\n        if (syllable.length) {\n            this.lastRawSyllable = syllable.concat(excess).join(\" \");\n            this.syllables.push(syllable.join(\" \"));\n        }\n        else { // Some donkus decided to create a pronunciation with no stressed phonemes\n            this.lastRawSyllable = this.pronunciation.phonemes.join(\" \");\n            this.syllables = [this.lastRawSyllable];\n        }\n    }\n\n    public get syllableCount(): number {\n        return this.syllables.length;\n    }\n\n    public get lastSyllable(): string {\n        return this.syllables[this.syllables.length - 1];\n    }\n}\n","import { Entry, getDict } from \"node-cmudict\";\nimport DataSet, { ensureDataSet } from \"./DataSet\";\nimport Fez from \"./Fez\";\n\nexport default class Limon {\n    private static _instance: Limon;\n\n    private _dict: Map<string, Entry> | null;\n    public readonly rhymeData: Map<string, DataSet<Fez>>;\n    public readonly cache: Map<string, DataSet<string>>;\n\n    private constructor() {\n        this._dict = null;\n        this.rhymeData = new Map<string, DataSet<Fez>>();\n        this.cache = new Map<string, DataSet<string>>();\n    }\n\n    /**\n     * Get the singleton instance of the class.\n     */\n    public static getInstance(): Limon {\n        if (!Limon._instance) {\n            Limon._instance = new Limon();\n        }\n        return Limon._instance;\n    }\n\n    public get dict() {\n        return this._dict;\n    }\n\n    public get initialized(): boolean {\n        return Boolean(this._dict && this.rhymeData.size);\n    }\n\n    /**\n     * Set the cmudict dictionary. Overwrites the current dictionary if it exists.\n     * @param dict The dictionary to use. Defaults to getting a new cmudict dictionary.\n     */\n    public setDict(dict?: Map<string, Entry>): void {\n        this._dict = dict ?? getDict();\n    }\n\n    /**\n     * Parse the dictionary for syllables\n     */\n    public init(): void {\n        if (!this._dict) {\n            this.setDict();\n        }\n        for (const entry of this._dict!.values()) {\n            for (const pronunciation of entry.pronunciations) {\n                const fez = new Fez(pronunciation);\n                if (fez.syllableCount === 1) {\n                    const data = ensureDataSet(this.rhymeData, fez.lastSyllable);\n                    if (!data.some(other => pronunciation.equals(other.pronunciation))) {\n                        data.add(fez);\n                    }\n                }\n            }\n        }\n    }\n\n    public exec(word: string, force: boolean = false): string | null {\n        if (!this.initialized) {\n            this.init();\n        }\n        const formatted = word.trim().toLowerCase();\n        if (!force) {\n            const cached = this.cache.get(formatted);\n            if (cached) {\n                return cached.random();\n            }\n        }\n        const entry = this._dict!.get(formatted);\n        if (!entry) {\n            return null;\n        }\n        const variations = ensureDataSet(this.cache, formatted);\n        for (const pronunciation of entry.pronunciations) {\n            const fez = new Fez(pronunciation);\n            let output: string[] = [];\n            for (let i = 0; i < fez.syllableCount; i++) {\n                const data = this.rhymeData.get(fez.syllables[i]);\n                if (data) {\n                    const rhymes = i === fez.syllableCount - 1 ?\n                        data.filter(other => other.lastRawSyllable === fez.lastRawSyllable) :\n                        data;\n                    const match = rhymes.random();\n                    if (match) {\n                        output.push(match.pronunciation.entry.name);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            if (output.length === fez.syllableCount) {\n                variations.add(output.join(\"\"));\n            }\n        }\n        return variations.random();\n    }\n}\n"],"mappings":"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","names":[]}